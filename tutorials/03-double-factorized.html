<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="next" title="The local unitary cluster Jastrow (LUCJ) ansatz" href="04-lucj.html" /><link rel="prev" title="Orbital rotations and quadratic Hamiltonians" href="02-orbital-rotation.html" />

    <!-- Generated with Sphinx 7.2.6 and Furo 2024.01.29 -->
        <title>Diagonal Coulomb operators and double-factorized Trotter simulation - ffsim 0.0.25.dev0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=135e06be" />
    <link rel="stylesheet" type="text/css" href="../_static/nbsphinx-code-cells.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=36a5483c" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">ffsim 0.0.25.dev0 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  
  <span class="sidebar-brand-text">ffsim 0.0.25.dev0 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="index.html">Tutorials</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Tutorials</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="01-introduction.html">Introduction to ffsim</a></li>
<li class="toctree-l2"><a class="reference internal" href="02-orbital-rotation.html">Orbital rotations and quadratic Hamiltonians</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">Diagonal Coulomb operators and double-factorized Trotter simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="04-lucj.html">The local unitary cluster Jastrow (LUCJ) ansatz</a></li>
<li class="toctree-l2"><a class="reference internal" href="05-entanglement-forging.html">Entanglement forging</a></li>
<li class="toctree-l2"><a class="reference internal" href="06-fermion-operator.html">The FermionOperator class</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../api/index.html">API Reference</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of API Reference</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../api/ffsim.html">ffsim</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/ffsim.contract.html">ffsim.contract</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/ffsim.linalg.html">ffsim.linalg</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/ffsim.optimize.html">ffsim.optimize</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/ffsim.random.html">ffsim.random</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/ffsim.testing.html">ffsim.testing</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="Diagonal-Coulomb-operators-and-double-factorized-Trotter-simulation">
<h1>Diagonal Coulomb operators and double-factorized Trotter simulation<a class="headerlink" href="#Diagonal-Coulomb-operators-and-double-factorized-Trotter-simulation" title="Link to this heading">#</a></h1>
<p>In this tutorial, we show how to use ffsim to simulate diagonal Coulomb operators and approximate time evolution by a molecular Hamiltonian in the double-factorized representation.</p>
<section id="Double-factorized-representation-of-the-molecular-Hamiltonian">
<h2>Double-factorized representation of the molecular Hamiltonian<a class="headerlink" href="#Double-factorized-representation-of-the-molecular-Hamiltonian" title="Link to this heading">#</a></h2>
<p>The molecular Hamiltonian is</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[H = \sum_{\sigma, pq} h_{pq} a^\dagger_{\sigma, p} a_{\sigma, q}
    + \frac12 \sum_{\sigma \tau, pqrs} h_{pqrs}
    a^\dagger_{\sigma, p} a^\dagger_{\tau, r} a_{\tau, s} a_{\sigma, q}
    + \text{constant}.\]</div>
</div>
<p>This representation of the Hamiltonian is daunting for quantum simulations because the number of terms scales as <span class="math notranslate nohighlight">\(N^4\)</span> where <span class="math notranslate nohighlight">\(N\)</span> is the number of spatial orbitals. An alternative representation can be obtained by performing a “double-factorization” of the two-body tensor <span class="math notranslate nohighlight">\(h_{pqrs}\)</span>:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[H = \sum_{\sigma, pq} h'_{pq} a^\dagger_{\sigma, p} a_{\sigma, q}
+ \sum_{k=1}^L \mathcal{W}_k \mathcal{J}_k \mathcal{W}_k^\dagger
+ \text{constant}'.\]</div>
</div>
<p>Here each <span class="math notranslate nohighlight">\(\mathcal{W}_k\)</span> is an <a class="reference internal" href="02-orbital-rotation.html"><span class="doc">orbital rotation</span></a> and each <span class="math notranslate nohighlight">\(\mathcal{J}_k\)</span> is a so-called diagonal Coulomb operator, which is an operator of the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathcal{J} = \frac12\sum_{\sigma \tau, ij} \mathbf{J}_{ij} n_{\sigma, i} n_{\tau, j},\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(n_{\sigma, i} = a^\dagger_{\sigma, i} a_{\sigma, i}\)</span> is the occupation number operator and <span class="math notranslate nohighlight">\(\mathbf{J}_{ij}\)</span> is a real symmetric matrix.</p>
<p>In the cell below, we construct the Hamiltonian for an ethene molecule at a stretched bond length and then get the double-factorized representation of the Hamiltonian.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyscf</span>

<span class="kn">import</span> <span class="nn">ffsim</span>

<span class="c1"># Build a stretched ethene molecule</span>
<span class="n">bond_distance</span> <span class="o">=</span> <span class="mf">2.678</span>
<span class="n">a</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">bond_distance</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mf">0.5626</span>
<span class="n">c</span> <span class="o">=</span> <span class="mf">0.9289</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">pyscf</span><span class="o">.</span><span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span>
<span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span>
    <span class="n">atom</span><span class="o">=</span><span class="p">[</span>
        <span class="p">[</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">)],</span>
        <span class="p">[</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">a</span><span class="p">)],</span>
        <span class="p">[</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">)],</span>
        <span class="p">[</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">)],</span>
        <span class="p">[</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">b</span><span class="p">)],</span>
        <span class="p">[</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">b</span><span class="p">)],</span>
    <span class="p">],</span>
    <span class="n">basis</span><span class="o">=</span><span class="s2">&quot;sto-6g&quot;</span><span class="p">,</span>
    <span class="n">symmetry</span><span class="o">=</span><span class="s2">&quot;d2h&quot;</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># Define active space</span>
<span class="n">active_space</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nelectron</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">nelectron</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1"># Get molecular data and molecular Hamiltonian (one- and two-body tensors)</span>
<span class="n">mol_data</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">MolecularData</span><span class="o">.</span><span class="n">from_mole</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">active_space</span><span class="o">=</span><span class="n">active_space</span><span class="p">)</span>
<span class="n">norb</span> <span class="o">=</span> <span class="n">mol_data</span><span class="o">.</span><span class="n">norb</span>
<span class="n">nelec</span> <span class="o">=</span> <span class="n">mol_data</span><span class="o">.</span><span class="n">nelec</span>
<span class="n">mol_hamiltonian</span> <span class="o">=</span> <span class="n">mol_data</span><span class="o">.</span><span class="n">hamiltonian</span>

<span class="c1"># Get the Hamiltonian in the double-factorized representation</span>
<span class="n">df_hamiltonian</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">DoubleFactorizedHamiltonian</span><span class="o">.</span><span class="n">from_molecular_hamiltonian</span><span class="p">(</span>
    <span class="n">mol_hamiltonian</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
converged SCF energy = -77.4456267643962
</pre></div></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">mol_hamiltonian</span></code> is an instance of <code class="docutils literal notranslate"><span class="pre">MolecularHamiltonian</span></code>, a dataclass that stores the one- and two-body tensors, and <code class="docutils literal notranslate"><span class="pre">df_hamiltonian</span></code> is an instance of <code class="docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian</span></code>, a dataclass that stores the updated one-body-tensor, diagonal Coulomb matrices, and orbital rotations. In the cell below, we print out the shapes of the tensors describing the original and double-factorized representations.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Original representation&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-----------------------&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;One-body tensor shape:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">mol_hamiltonian</span><span class="o">.</span><span class="n">one_body_tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Two-body tensor shape:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">mol_hamiltonian</span><span class="o">.</span><span class="n">two_body_tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Double-factorized representation&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--------------------------------&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;One-body tensor shape:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">df_hamiltonian</span><span class="o">.</span><span class="n">one_body_tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Diagonal Coulomb matrices shape:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">df_hamiltonian</span><span class="o">.</span><span class="n">diag_coulomb_mats</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Orbital rotations shape:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">df_hamiltonian</span><span class="o">.</span><span class="n">orbital_rotations</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Original representation
-----------------------
One-body tensor shape:
(4, 4)

Two-body tensor shape:
(4, 4, 4, 4)

Double-factorized representation
--------------------------------
One-body tensor shape:
(4, 4)

Diagonal Coulomb matrices shape:
(10, 4, 4)

Orbital rotations shape:
(10, 4, 4)
</pre></div></div>
</div>
</section>
<section id="Trotter-simulation-of-the-double-factorized-Hamiltonian">
<h2>Trotter simulation of the double-factorized Hamiltonian<a class="headerlink" href="#Trotter-simulation-of-the-double-factorized-Hamiltonian" title="Link to this heading">#</a></h2>
<p>In the rest of this tutorial, we’ll show how to use ffsim to implement time evolution of the double-factorized Hamiltonian via Trotter-Suzuki formulas. Although ffsim already has this functionality built-in, we will first manually implement a first-order asymmetric product formula to demonstrate the use of ffsim’s basic operations.</p>
<section id="Brief-background-on-Trotter-Suzuki-formulas">
<h3>Brief background on Trotter-Suzuki formulas<a class="headerlink" href="#Brief-background-on-Trotter-Suzuki-formulas" title="Link to this heading">#</a></h3>
<p>Trotter-Suzuki formulas are used to approximate time evolution by a Hamiltonian <span class="math notranslate nohighlight">\(H\)</span> which is decomposed as a sum of terms:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[H = \sum_k H_k.\]</div>
</div>
<p>Time evolution by time <span class="math notranslate nohighlight">\(t\)</span> is given by the unitary operator</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[e^{i H t}.\]</div>
</div>
<p>To approximate this operator, the total evolution time is first divided into a number of smaller time steps, called “Trotter steps”:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[e^{i H t} = (e^{i H t / r})^r.\]</div>
</div>
<p>The time evolution for a single Trotter step is then approximated using a product formula, which approximates the exponential of a sum of terms by a product of exponentials of the individual terms. The formulas are approximate because the terms do not in general commute. A first-order asymmetric product formula has the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[e^{i H \tau} \approx \prod_k e^{i H_k \tau}.\]</div>
</div>
<p>Higher-order formulas can be derived which yield better approximations.</p>
</section>
<section id="Implementing-Trotter-simulation-of-the-double-factorized-Hamiltonian">
<h3>Implementing Trotter simulation of the double-factorized Hamiltonian<a class="headerlink" href="#Implementing-Trotter-simulation-of-the-double-factorized-Hamiltonian" title="Link to this heading">#</a></h3>
<p>First, we’ll write a function to simulate a single Trotter step of the Hamiltonian. Recall the form of the Hamiltonian (ignoring the additive constant):</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[H = \sum_{\sigma, pq} h'_{pq} a^\dagger_{\sigma, p} a_{\sigma, q}
+ \sum_{k=1}^L \mathcal{W}_k \mathcal{J}_k \mathcal{W}_k^\dagger\]</div>
</div>
<p>We think of this Hamiltonian as composed of <span class="math notranslate nohighlight">\(L + 1\)</span> terms: the one-body term, which is a quadratic Hamiltonian, and the <span class="math notranslate nohighlight">\(L\)</span> “rotated diagonal Coulomb operators.” As described in <a class="reference internal" href="02-orbital-rotation.html"><span class="doc">this tutorial</span></a>, time evolution by the quadratic Hamiltonian can be implemented using the <code class="docutils literal notranslate"><span class="pre">apply_num_op_sum_evolution</span></code> function. Similarly, time evolution by a rotated diagonal coulomb operator can be implemented using the <code class="docutils literal notranslate"><span class="pre">apply_diag_coulomb_evolution</span></code> function.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<span class="k">def</span> <span class="nf">simulate_trotter_step_double_factorized</span><span class="p">(</span>
    <span class="n">vec</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">hamiltonian</span><span class="p">:</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">DoubleFactorizedHamiltonian</span><span class="p">,</span>
    <span class="n">time</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">norb</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">nelec</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="c1"># Diagonalize the one-body term</span>
    <span class="n">one_body_energies</span><span class="p">,</span> <span class="n">one_body_basis_change</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span>
        <span class="n">hamiltonian</span><span class="o">.</span><span class="n">one_body_tensor</span>
    <span class="p">)</span>
    <span class="c1"># Simulate the one-body term</span>
    <span class="n">vec</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">apply_num_op_sum_evolution</span><span class="p">(</span>
        <span class="n">vec</span><span class="p">,</span>
        <span class="n">one_body_energies</span><span class="p">,</span>
        <span class="n">time</span><span class="p">,</span>
        <span class="n">norb</span><span class="o">=</span><span class="n">norb</span><span class="p">,</span>
        <span class="n">nelec</span><span class="o">=</span><span class="n">nelec</span><span class="p">,</span>
        <span class="n">orbital_rotation</span><span class="o">=</span><span class="n">one_body_basis_change</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># Simulate the two-body terms</span>
    <span class="k">for</span> <span class="n">diag_coulomb_mat</span><span class="p">,</span> <span class="n">orbital_rotation</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
        <span class="n">hamiltonian</span><span class="o">.</span><span class="n">diag_coulomb_mats</span><span class="p">,</span> <span class="n">hamiltonian</span><span class="o">.</span><span class="n">orbital_rotations</span>
    <span class="p">):</span>
        <span class="n">vec</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">apply_diag_coulomb_evolution</span><span class="p">(</span>
            <span class="n">vec</span><span class="p">,</span>
            <span class="n">diag_coulomb_mat</span><span class="p">,</span>
            <span class="n">time</span><span class="p">,</span>
            <span class="n">norb</span><span class="o">=</span><span class="n">norb</span><span class="p">,</span>
            <span class="n">nelec</span><span class="o">=</span><span class="n">nelec</span><span class="p">,</span>
            <span class="n">orbital_rotation</span><span class="o">=</span><span class="n">orbital_rotation</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">vec</span>
</pre></div>
</div>
</div>
<p>We finish by writing a higher-level function that handles splitting the total time evolution into multiple Trotter steps, simulating each Trotter step using the function we just wrote.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">simulate_trotter_double_factorized</span><span class="p">(</span>
    <span class="n">vec</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">hamiltonian</span><span class="p">:</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">DoubleFactorizedHamiltonian</span><span class="p">,</span>
    <span class="n">time</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">norb</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">nelec</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="n">n_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="n">step_time</span> <span class="o">=</span> <span class="n">time</span> <span class="o">/</span> <span class="n">n_steps</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_steps</span><span class="p">):</span>
        <span class="n">vec</span> <span class="o">=</span> <span class="n">simulate_trotter_step_double_factorized</span><span class="p">(</span>
            <span class="n">vec</span><span class="p">,</span>
            <span class="n">hamiltonian</span><span class="p">,</span>
            <span class="n">step_time</span><span class="p">,</span>
            <span class="n">norb</span><span class="o">=</span><span class="n">norb</span><span class="p">,</span>
            <span class="n">nelec</span><span class="o">=</span><span class="n">nelec</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">vec</span>
</pre></div>
</div>
</div>
<p>To test our implementation, we’ll apply the time evolution to the Hartree-Fock state, which is a Slater determinant with electrons occupying the lowest-energy molecular orbitals. In the following code cell, we’ll create this state and calculate its energy. It should match the value output by pySCF when we first created the molecule. To calculate the energy, we convert the Hamiltonian to a SciPy <code class="docutils literal notranslate"><span class="pre">LinearOperator</span></code>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Construct the Hartree-Fock state</span>
<span class="n">initial_state</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">hartree_fock_state</span><span class="p">(</span><span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">)</span>

<span class="c1"># Get the Hamiltonian as a LinearOperator</span>
<span class="n">hamiltonian</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">linear_operator</span><span class="p">(</span><span class="n">mol_hamiltonian</span><span class="p">,</span> <span class="n">norb</span><span class="o">=</span><span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="o">=</span><span class="n">nelec</span><span class="p">)</span>

<span class="c1"># Check the energy ⟨ψ|H|ψ⟩ of the Hartree-Fock state</span>
<span class="n">hf_energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">initial_state</span><span class="p">,</span> <span class="n">hamiltonian</span> <span class="o">@</span> <span class="n">initial_state</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Hartree Fock energy: </span><span class="si">{</span><span class="n">hf_energy</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Hartree Fock energy: -77.44562676439628
</pre></div></div>
</div>
<p>Now, we set the evolution time and calculate the exact result of time evolution by directly exponentiating the Hamiltonian using SciPy. Later, we will compare the result of our approximate time evolution with this exact result.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">scipy.sparse.linalg</span>

<span class="n">time</span> <span class="o">=</span> <span class="mf">5.0</span>

<span class="n">exact_state</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">expm_multiply</span><span class="p">(</span>
    <span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">time</span> <span class="o">*</span> <span class="n">hamiltonian</span><span class="p">,</span>
    <span class="n">initial_state</span><span class="p">,</span>
    <span class="n">traceA</span><span class="o">=</span><span class="n">ffsim</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">mol_hamiltonian</span><span class="p">,</span> <span class="n">norb</span><span class="o">=</span><span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="o">=</span><span class="n">nelec</span><span class="p">),</span>
<span class="p">)</span>

<span class="n">fidelity</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">exact_state</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fidelity of evolved state w.r.t. initial state: </span><span class="si">{</span><span class="n">fidelity</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Fidelity of evolved state w.r.t. initial state: 0.9315062301403367
</pre></div></div>
</div>
<p>Now, let’s test our implementation.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">final_state</span> <span class="o">=</span> <span class="n">simulate_trotter_double_factorized</span><span class="p">(</span>
    <span class="n">initial_state</span><span class="p">,</span>
    <span class="n">df_hamiltonian</span><span class="p">,</span>
    <span class="n">time</span><span class="p">,</span>
    <span class="n">norb</span><span class="o">=</span><span class="n">norb</span><span class="p">,</span>
    <span class="n">nelec</span><span class="o">=</span><span class="n">nelec</span><span class="p">,</span>
    <span class="n">n_steps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">fidelity</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">final_state</span><span class="p">,</span> <span class="n">exact_state</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fidelity of Trotter-evolved state with exact state: </span><span class="si">{</span><span class="n">fidelity</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Fidelity of Trotter-evolved state with exact state: 0.9928527668217099
</pre></div></div>
</div>
<p>The fidelity of the final result can be improved by increasing the number of Trotter steps.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">final_state</span> <span class="o">=</span> <span class="n">simulate_trotter_double_factorized</span><span class="p">(</span>
    <span class="n">initial_state</span><span class="p">,</span>
    <span class="n">df_hamiltonian</span><span class="p">,</span>
    <span class="n">time</span><span class="p">,</span>
    <span class="n">norb</span><span class="o">=</span><span class="n">norb</span><span class="p">,</span>
    <span class="n">nelec</span><span class="o">=</span><span class="n">nelec</span><span class="p">,</span>
    <span class="n">n_steps</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">fidelity</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">final_state</span><span class="p">,</span> <span class="n">exact_state</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fidelity of Trotter-evolved state with exact state: </span><span class="si">{</span><span class="n">fidelity</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Fidelity of Trotter-evolved state with exact state: 0.999932085129046
</pre></div></div>
</div>
<p>As mentioned above, ffsim already includes functionality for Trotter simulation of double-factorized Hamiltonians. The implementation in ffsim includes higher-order Trotter-Suzuki formulas. The first-order asymmetric formula that we just implemented corresponds to <code class="docutils literal notranslate"><span class="pre">order=0</span></code> in ffsim’s implementation. <code class="docutils literal notranslate"><span class="pre">order=1</span></code> corresponds to the first-order symmetric (commonly known as the second-order) formula, <code class="docutils literal notranslate"><span class="pre">order=2</span></code> corresponds to the second-order symmetric (fourth-order) formula, and so on.</p>
<p>In the code cell below, we reproduce the results of our manually implemented function using ffsim’s built-in implementation.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">final_state</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">simulate_trotter_double_factorized</span><span class="p">(</span>
    <span class="n">initial_state</span><span class="p">,</span>
    <span class="n">df_hamiltonian</span><span class="p">,</span>
    <span class="n">time</span><span class="p">,</span>
    <span class="n">norb</span><span class="o">=</span><span class="n">norb</span><span class="p">,</span>
    <span class="n">nelec</span><span class="o">=</span><span class="n">nelec</span><span class="p">,</span>
    <span class="n">n_steps</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">fidelity</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">final_state</span><span class="p">,</span> <span class="n">exact_state</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fidelity of Trotter-evolved state with exact state: </span><span class="si">{</span><span class="n">fidelity</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Fidelity of Trotter-evolved state with exact state: 0.999932085129046
</pre></div></div>
</div>
<p>A higher order formula achieves a higher fidelity with fewer Trotter steps:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">final_state</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">simulate_trotter_double_factorized</span><span class="p">(</span>
    <span class="n">initial_state</span><span class="p">,</span>
    <span class="n">df_hamiltonian</span><span class="p">,</span>
    <span class="n">time</span><span class="p">,</span>
    <span class="n">norb</span><span class="o">=</span><span class="n">norb</span><span class="p">,</span>
    <span class="n">nelec</span><span class="o">=</span><span class="n">nelec</span><span class="p">,</span>
    <span class="n">n_steps</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">fidelity</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">final_state</span><span class="p">,</span> <span class="n">exact_state</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fidelity of Trotter-evolved state with exact state: </span><span class="si">{</span><span class="n">fidelity</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Fidelity of Trotter-evolved state with exact state: 0.9999913261311401
</pre></div></div>
</div>
</section>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="04-lucj.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">The local unitary cluster Jastrow (LUCJ) ansatz</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="02-orbital-rotation.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Orbital rotations and quadratic Hamiltonians</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2023, IBM
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              <a class="muted-link " href="https://github.com/qiskit-community/ffsim" aria-label="GitHub">
                <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path>
                </svg>
            </a>
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Diagonal Coulomb operators and double-factorized Trotter simulation</a><ul>
<li><a class="reference internal" href="#Double-factorized-representation-of-the-molecular-Hamiltonian">Double-factorized representation of the molecular Hamiltonian</a></li>
<li><a class="reference internal" href="#Trotter-simulation-of-the-double-factorized-Hamiltonian">Trotter simulation of the double-factorized Hamiltonian</a><ul>
<li><a class="reference internal" href="#Brief-background-on-Trotter-Suzuki-formulas">Brief background on Trotter-Suzuki formulas</a></li>
<li><a class="reference internal" href="#Implementing-Trotter-simulation-of-the-double-factorized-Hamiltonian">Implementing Trotter simulation of the double-factorized Hamiltonian</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=7986223a"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=32e29ea5"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>